int _tmain(int argc, _TCHAR* argv[])
{
	//Сортировка выбором
	/*Идея метода состоит в том, чтобы создавать отсортированную последовательность путем присоединения 
	к ней одного элемента за другим в правильном порядке. Если входная последовательность почти упорядочена, 
	то сравнений будет столько же, значит алгоритм ведет себя неестественно.*/
	int size = 5;
	int arr[5] = { 1, 4, 2, 3, 5 };
	int tmp, i, j, pos;
	for (i = 0; i < size; i++) // i - номер текущего шага
	{
		pos = i;
		tmp = arr[i];
		for (j = i + 1; j < size; ++j) // цикл выбора наименьшего элемента
		{
			if (arr[j] < tmp)
			{
				pos = j;
				tmp = arr[j];
			}
		}
		arr[pos] = arr[i];
		arr[i] = tmp; // меняем местами наименьший с a[i]
	}
	for (i = 0; i < size; i++){
		printf("%d\n", arr[i]);
	}
	_getch();
	return 0;
}
----------------------------------------------------------------------
/*Сортировка пузырьком - это метод сортировки массивов и списков путем последовательного сравнения и обмена соседних элементов, 
если предшествующий оказывается больше последующего. В процессе выполнения данного алгоритма элементы с большими значениями оказываются 
в конце списка, а элементы с меньшими значениями постепенно перемещаются по направлению к началу списка. Образно говоря, тяжелые элементы 
падают на дно, а легкие медленно всплывают подобно пузырькам воздуха.
В сортировке методом пузырька количество итераций внешнего цикла определяется длинной списка минус единица, 
так как когда второй элемент становится на свое место, то первый уже однозначно минимальный и находится на своем месте.
Количество итераций внутреннего цикла зависит от номера итерации внешнего цикла, так как конец списка уже отсортирован, 
и выполнять проход по этим элементам смысла нет. 

Пусть имеется список [6, 12, 4, 3, 8]. 

За первую итерацию внешнего цикла число 12 переместится в конец. Для этого потребуется 4 сравнения во внутреннем цикле:

6 > 12? Нет
12 > 4? Да. Меняем местами
12 > 3? Да. Меняем местами
12 > 8? Да. Меняем местами
Результат: [6, 4, 3, 8, 12]

За вторую итерацию внешнего цикла число 8 переместиться на предпоследнее место. Для этого потребуется 3 сравнения:

6 > 4? Да. Меняем местами
6 > 3? Да. Меняем местами
6 > 8? Нет
Результат: [4, 3, 6, 8, 12]

На третьей итерации внешнего цикла исключаются два последних элемента. Количество итераций внутреннего цикла равно двум:

4 > 3? Да. Меняем местами
4 > 6? Нет
Результат: [3, 4, 6, 8, 12]

На четвертой итерации внешнего цикла осталось сравнить только первые два элемента, поэтому количество итераций внутреннего равно единице:

3  > 4? Нет
Результат: [3, 4, 6, 8, 12]
*/

int _tmain(int argc, _TCHAR* argv[])
{
	int tmp, i, j;
	int arr[5] = { 1, 4, 2, 3, 5 };
	int size = 5; 
	for (i = 0; i < size - 1; ++i) // i - номер прохода
	{
		for (j = 0; j < size - 1; ++j) // внутренний цикл прохода
		{
			if (arr[j + 1] < arr[j])
			{
				tmp = arr[j + 1];
				arr[j + 1] = arr[j];
				arr[j] = tmp;
			}
		}
	}
	for (int i = 0; i < size; i++){
		printf("%d", arr[i]);
	}
	_getch();
	return 0;
}
----------------------------------------------------------------------------------------------------------------
/*#сортировка вставками
"""Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки. Суть его заключается в том что, 
на каждом шаге алгоритма мы берем один из элементов массива, находим позицию для вставки и вставляем. 
Стоит отметить что массив из 1-го элемента считается отсортированным.*/


int _tmain(int argc, _TCHAR* argv[])
{
	int arr[5] = { 1, 4, 2, 3, 5 };
	int size = 5; 
	int i, j, tmp;
	for (i = 1; i < size; ++i) // цикл проходов, i - номер прохода
	{
		tmp = arr[i];
		for (j = i - 1; j >= 0 && arr[j] > tmp; j--) // поиск места элемента в готовой последовательности 
			arr[j + 1] = arr[j];    // сдвигаем элемент направо, пока не дошли
		arr[j + 1] = tmp; // место найдено, вставить элемент    
	}
	for (int i = 0; i < size; i++){
		printf("%d", arr[i]);
	}
	_getch();
	return 0;
}