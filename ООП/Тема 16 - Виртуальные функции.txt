// Тема 16 - Полиморфизм и Виртуальные функции 

// Полиморфизм в C++ - это возможность объектов разных классов использовать одинаковые методы или операторы, но вести себя по-разному в 
// зависимости от своего типа или класса. Полиморфизм позволяет использовать один и тот же интерфейс для работы с объектами разных типов, // что делает код более гибким и удобным для использования. В C++ полиморфизм достигается за счет использования виртуальных функций и 
// наследования.

// При вызове функции программа должна определять, с какой именно реализацией функции соотносить этот вызов, то есть связать вызов функции с самой функцией. В С++ есть два типа связывания - статическое и динамическое.

// Когда вызовы функций фиксируются до выполнения программы на этапе компиляции, это называется статическим связыванием 
// (static binding), либо ранним связыванием (early binding). При этом вызов функции через указатель определяется 
// исключительно типом указателя, а не объектом, на который он указывает. Например:
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
    Person(string name): name{name}
    { }
    virtual void print() const
    //void print() const
    {
        cout << "Name: " << name << endl;
    }
private:
    string name;       
};
class Student: public Person
{
public:
    Student(std::string name, std::string company): Person{name}, company{company}
    { }
    void print() const
    {
        Person::print();
        cout << "Study in " << company << std::endl;
    }
private:
    string company;    // компания
};

// Другой тип связывания представляет динамическое связывание (dynamic binding), еще называют поздним связыванием (late binding), 
// которое позволяет на этапе выполнения решать, функцию какого типа вызвать. Для этого в языке С++ применяют виртуальные функции. 
// Для определения виртуальной функции в базовом классе функция определяется с ключевым словом virtual. 
// Причем данное ключевое слово можно применить к функции, если она определена внутри класса. А производный класс может переопределить ее поведение.

// Класс, который определяет или наследует виртуальную функцию, еще назвается полиморфным (polymorphic class). 
// То есть в данном случае Person и Employee являются полиморфными классами.

int main()
{
    // Динамическое связывание возможно только через указатель или ссылку.
    Person tom {"Tom"};
    Person* person {&tom};
    person->print();     // Name: Tom
    Student bob {"Bob", "Microsoft"};
    person = &bob;
    person->print();    // Name: Bob
}

// При определении вирутальных функций есть ряд ограничений. Чтобы функция попадала под динамическое связывание, 
// в производном классе она должна иметь тот же самый набор параметров и возвращаемый тип, что и в базовом классе. 
// Например, если в базовом классе виртуальная функция определена как константная, то в производном классе она тоже должна 
// быть константной. Если же функция имеет разный набор параметров или несоответствие по константности,
// то мы будем иметь дело со скрытием функций, а не переопределением. И тогда будет применяться статическое связывание.

