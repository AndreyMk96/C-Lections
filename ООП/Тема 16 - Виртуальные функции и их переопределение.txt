// Тема 16 - Виртуальные функции и их переопределение

// При вызове функции программа должна определять, с какой именно реализацией функции соотносить этот вызов, то есть связать вызов функции с самой функцией. В С++ есть два типа связывания - статическое и динамическое.

// Когда вызовы функций фиксируются до выполнения программы на этапе компиляции, это называется статическим связыванием 
// (static binding), либо ранним связыванием (early binding). При этом вызов функции через указатель определяется 
// исключительно типом указателя, а не объектом, на который он указывает. Например:
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
    Person(std::string name): name{name}
    { }
    virtual void print() const
    //void print() const
    {
        std::cout << "Name: " << name << std::endl;
    }
private:
    std::string name;       
};
class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}
    { }
    void print() const
    {
        Person::print();
        cout << "Works in " << company << std::endl;
    }
private:
    std::string company;    // компания
};

// Другой тип связывания представляет динамическое связывание (dynamic binding), еще называют поздним связыванием (late binding), 
// которое позволяет на этапе выполнения решать, функцию какого типа вызвать. Для этого в языке С++ применяют виртуальные функции. 
// Для определения виртуальной функции в базовом классе функция определяется с ключевым словом virtual. 
// Причем данное ключевое слово можно применить к функции, если она определена внутри класса. А производный класс может переопределить ее поведение.

// Класс, который определяет или наследует виртуальную функцию, еще назвается полиморфным (polymorphic class). 
// То есть в данном случае Person и Employee являются полиморфными классами.

int main()
{
    // Динамическое связывание возможно только через указатель или ссылку.
    Person tom {"Tom"};
    Person* person {&tom};
    person->print();     // Name: Tom
    Employee bob {"Bob", "Microsoft"};
    person = &bob;
    person->print();    // Name: Bob
}

// При определении вирутальных функций есть ряд ограничений. Чтобы функция попадала под динамическое связывание, 
// в производном классе она должна иметь тот же самый набор параметров и возвращаемый тип, что и в базовом классе. 
// Например, если в базовом классе виртуальная функция определена как константная, то в производном классе она тоже должна 
// быть константной. Если же функция имеет разный набор параметров или несоответствие по константности, то мы будем иметь дело со скрытием функций, а не переопределением. И тогда будет применяться статическое связывание.

