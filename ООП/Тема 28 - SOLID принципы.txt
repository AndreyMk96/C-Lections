// Тема 28 - SOLID - принципы

//Принципы SOLID — это набор пяти основных принципов объектно-ориентированного программирования и проектирования, 
//которые помогают создавать более гибкие, расширяемые и поддерживаемые системы. Эти принципы были сформулированы 
//Робертом Мартином и стали основой для разработки качественного и чистого кода. Давай рассмотрим каждый из принципов:

/*1. Принцип единственной ответственности (Single Responsibility Principle, SRP):
   Как уже упоминалось ранее, этот принцип гласит, что класс должен иметь только одну причину для изменения. Каждый класс должен быть ответственен только за одну четко определенную часть функциональности.
   
   Принцип единственной ответственности (Single Responsibility Principle, SRP) — это один из принципов объектно-ориентированного 
   программирования, сформулированный Робертом Мартином. Он утверждает, что класс должен иметь только одну причину для изменения, то есть он должен быть ответственен только за одну важную часть функциональности.
   
   Суть принципа заключается в том, что класс должен выполнять только одну задачу или иметь только одну обязанность. 
   Это облегчает поддержку кода, его понимание и разработку. Если класс выполняет слишком много различных задач, это усложняет 
   его использование, повышает риск ошибок и затрудняет его изменение в будущем.
   
   Применение принципа единственной ответственности помогает создавать более чистый и модульный код, улучшает его читаемость, 
   облегчает тестирование и поддержку. Кроме того, это способствует уменьшению связанности между компонентами программы, 
   что делает систему более гибкой и расширяемой.
   
   Для соблюдения SRP рекомендуется разделять функциональность на отдельные классы или модули таким образом, чтобы каждый класс 
   отвечал за конкретную задачу или аспект системы. Это позволяет легко изменять код без необходимости вносить изменения 
   во все компоненты программы и уменьшает вероятность появления ошибок из-за нежелательных побочных эффектов.*/

/*2. Принцип открытости/закрытости (Open/Closed Principle, OCP):
   Этот принцип утверждает, что классы должны быть открыты для расширения, но закрыты для модификации. Это означает, что поведение класса должно быть изменяемо без изменения самого класса.

    Согласно этому принципу, программные сущности, такие как классы, модули, функции и т.д., должны быть открыты для расширения, 
    но закрыты для модификации.

    Это означает, что поведение сущности может быть изменено путем добавления нового кода, но не путем изменения существующего. 
    Таким образом, код должен быть спроектирован таким образом, чтобы изменения в требованиях могли быть обработаны без изменения 
    самого исходного кода.

    Применение принципа открытости/закрытости способствует улучшению читаемости, поддерживаемости и расширяемости кода. 
    Он стимулирует использование абстракций, интерфейсов и наследования для обеспечения гибкости и возможности легкого добавления 
    новой функциональности без изменения существующего кода.*/

/*3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):
   Суть этого принципа заключается в том, что объекты базового класса должны быть заменяемы объектами его подклассов без изменения желательных свойств программы. То есть подклассы должны быть взаимозаменяемы с базовым классом.

4. Принцип разделения интерфейса (Interface Segregation Principle, ISP):
   Этот принцип утверждает, что интерфейсы должны быть разделены на более мелкие специализированные интерфейсы, чтобы клиенты могли использовать только те методы, которые им нужны, а не нести избыточные зависимости.

5. Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):
   Согласно этому принципу, модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Кроме того, абстракции не должны зависеть от деталей, но детали должны зависеть от абстракций.*/

Соблюдение принципов SOLID помогает создавать более гибкие, расширяемые и поддерживаемые системы, а также способствует уменьшению связанности между компонентами программы и повышению их переиспользуемости.