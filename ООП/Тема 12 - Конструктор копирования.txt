/* Тема 10 - конструктор копирования*/

#include <iostream>
using namespace std;

// По умолчанию компилятор при компиляции классов генерирует специальный конструктор - конструктор копирования, 
// который позволяет создать объект на основе другого объекта (по сути копирует объект). 
// Конструктор копирования по умолчанию копирует значения полей объекта, в новый объект

// Конструктор копирования можно использовать при создании объекта на основе другого

class Student{
public:
    string name;
    int *points = new int[5];
    Student(string name){
        this->name = name;
        cout << "student created" << endl;
    }
    ~Student(){
        cout << "student expelled" << endl;
        delete points;
    }
    //Создадим конструтктор копирования
    //Принимаемый объект мы не меняем, поэтому рекомендуется его сделать константным
    //Объект принимается по ссылке
    Student(const Student &s){
        cout << "student copy created" << endl;
        this->points = new int[5]; // Теперь динамический массив points создается для каждого объекта    
        this->name = s.name; // Также копируем имя, чтобы ячейка была не пустая
    }
};

// В функции можно передавать объекты класса
void PrintName(Student s){
    cout << s.name << endl;
}

 
int main()
{
    Student s1("Ivan");
    PrintName(s1);
    // Через конструктор копирования можно сосздавать объект на основе объекта
    // (даже если конструктор копирования неявно определен компилятором)
    Student s2(s1);
    PrintName(s2);
    //Обратим внимание, что деструктор вызвался аж 4 раза, а конструктор - 1 раз
    // (два обьекта + 2 копии обьекта, тк обьекты в функцию PrintName передаются копированием)
    // Если в деструкторе происходит очищение памяти - это приведет к вылету
    // Также конструктор копирования вызывается при копировании объекта в функцию, а просто конструктор - нет
}